use std::str::FromStr;
use crate::ast::{Expr, ExprOpcode, LogicalExpr, LogicalOpcode, LogicalExprOpcode};

grammar;

// ----- ARITHMETIC EXPRESSIONS ----- 

pub Expr : Box<Expr> = {
  Expr ExprOp Expr2 => Box::new(Expr::ExprOp(<>)),
  Expr2,
};

Expr2: Box<Expr> = {
  Expr2 Expr2Op Var => Box::new(Expr::ExprOp(<>)),
  Var,
};

Var: Box<Expr> = {
  NumLiteral => Box::new(Expr::Number(<>)),
  Variable => Box::new(Expr::Variable(<>)),
};

NumLiteral: i32 = {
  r"[0-9]+" => i32::from_str(<>).unwrap(), 
};

Variable: String = {
  <s:r"[a-zA-Z]+"> => s.to_string(),
};


ExprOp: ExprOpcode = { // (3)
  "+" => ExprOpcode::Add,
};

Expr2Op: ExprOpcode = {
  "*" => ExprOpcode::Mul,
};


// // ----- LOGICAL EXPRESSIONS ----- 

pub LogicalExpr: Box<LogicalExpr> = {
  "!" <a:LogicalExpr> => Box::new(LogicalExpr::Not(a)),
  LogicalExpr2
};

LogicalExpr2: Box<LogicalExpr> = {
  LogicalExpr2 LogicalOp LogicalExpr3 => Box::new(LogicalExpr::LogicalOp(<>)),
  LogicalExpr3,
};

LogicalExpr3: Box<LogicalExpr> = {
  LogicalExpr3 LogicalExprOp LogicalExpr4 => Box::new(LogicalExpr::LogicalExprOp(<>)),
  Expr,
};

LogicalExpr4: Box<Expr> = {
  Expr
};

LogicalOp: LogicalOpcode = {
  "&" => LogicalOpcode::And,
};

LogicalExprOp: LogicalExprOpcode = {
  "<" => LogicalExprOpcode::LessThan,
};

// // ----- COMMANDS -----


// // skip | x := e | C; C | {C} [p] {C} | if (Ï†) {C} else {C}

// pub Command: Box<Command> = {
//   "skip" => Box<Command::Skip>,
//   // var
//   <l:Command> ";" <r:Command2> => Box::new(Command::Sequence(<>)),
//   Command2,
// }

// Command2: Box<Command> = {
//   "{" <l:Command2> "}" "[" <p:Probability> "]" "{" <r:Command2> "}" => Box::new(Command::ProbabilisticChoice(<>)),
//   Command3,
// }

// Command3: Box<Command> = {
//   "if" "(" <c:LogicalExpr> ")" "{" <l:Command2> "}" "else" "{" <r:Command2> "}"
//   Command3,
// }

// Probability: f32 = {
//   r"[+-]?[0-9]*\.[0-9]+" => Box::new(Expr::Literal(f32::from_str(<>).unwrap())),
// }